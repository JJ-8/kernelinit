#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <linux/userfaultfd.h>


typedef void (*racehandler_func)();
typedef struct {
    int uffd;
    void* race_page;
    racehandler_func func;

} racer_arg_t;
int racer(void *arg) {
    struct uffd_msg uf_msg;
    
    int uffd = ((racer_arg_t*)arg)->uffd;
    void* race_page = ((racer_arg_t*)arg)->race_page;
    racehandler_func handle_race = ((racer_arg_t*)arg)->func;
    free(arg);

    struct pollfd pollfd = { .fd = uffd, .events = POLLIN };

    while (poll(&pollfd, 1, -1) > 0) {
        if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP) {
            exit(-1);
        }
        if (read(uffd, &uf_msg, sizeof(uf_msg)) == 0) {
            perror("read");
            exit(-1);
        }
        if (uf_msg.event != UFFD_EVENT_PAGEFAULT) {
            perror("unexpected pagefault");
            exit(-1);
        }

        char uf_buffer[0x1000];

        printf("faulting here: %p\n", race_page);
        handle_race(uf_buffer);

        struct uffdio_copy uf_copy = {
            .src = (uint64_t) uf_buffer,
            .dst = (uint64_t) race_page,
            .len = 0x1000, .mode = 0, .copy = 0
        };
        if (ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1) {
            perror("UFFDIO_COPY");
            exit(-1);
        }

        struct uffdio_range uf_range = {
            .start = (uint64_t) race_page, .len = 0x1000
        };
        if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1) {
            perror("UFFDIO_UNREGISTER");
        }
        if (munmap(race_page, 0x1000) == -1) {
            perror("munmap");
        }

        return 0;
    }
    return 0;
}

int register_userfault(void* race_page, racehandler_func func) {
    int uffd;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);

    struct uffdio_api uf_api = { .api = UFFD_API, .features = 0 };
    if (ioctl(uffd, UFFDIO_API, (unsigned long)&uf_api) == -1) {
        perror("UFFDIO_API failed");
        exit(-1);
    }

    if (mmap(race_page, 0x1000, PROT_WRITE | PROT_READ, MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page) {
        perror("mmap failed");
        exit(-1);
    }

    struct uffdio_register uf_register = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = (uint64_t) race_page,
            .len = 0x1000
        }
    };

    if (ioctl(uffd, UFFDIO_REGISTER, (unsigned long)&uf_register) == -1) {
        perror("UFFDIO_REGISTER failed");
        exit(-1);
    }

    void *stack = malloc(0x8000);    // Stack for new process
    if(!stack) {
            perror("Malloc Failed");
            exit(0);
    }

    racer_arg_t *racer_arg = malloc(sizeof(racer_arg_t));
    racer_arg->uffd = uffd;
    racer_arg->race_page = race_page;
    racer_arg->func = func;

    int pid = clone(&racer, (char *)stack + 0x8000, CLONE_VM | CLONE_FILES, racer_arg);
    if( pid < 0 ){
            perror("Clone Failed");
            exit(-1);
    }
    return pid;
}

/*
Example use:

void handle_userfault (void* uf_buffer) {
    printf("Handle userfaultfd!\n");
}

...

    register_userfault((void*)0xbaad0000, handle_userfault);
*/
